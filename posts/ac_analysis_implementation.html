<!doctype html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>Crisp Blog</title>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <link rel="stylesheet" type="text/css" href="../css/slim.css" />
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300..700&display=swap" rel="stylesheet">
    </head>

    <body>
    <div class="container">
        <div class="header">
            <h1 class="site-title"><a href="../">Crisp Blog</a></h1>
            <div class="nav">
                <a class="nav-btn" href="#">
                    <span class="ci ci-burger"></span>
                </a>
                <ul class="nav-list">
                    
                    <li class="spacer">∾</li>
                    <li><a href="../">Home</a></li>
                    <li><a href="mailto:bodw3@qq.com">Contact</a></li>
                </ul>
            </div>
        </div>


        <div class="content">
            <div class="post">
    <h1 class="post-title"><a href>使用python实现简单的电路频响分析工具</a></h1>
    <div class="post-date">July 10, 2024</div>

    <div class="post-content">
        <p>本文将使用python实现一个工具，完成类似SPICE的AC Analysis的功能。此外，我们尝试使用该工具生成TS808 Tone部分电路的频响曲线，并提供一定交互性以更好地观察和理解TS808 Tone部分的特性。</p>
<div>

</div>
<!--more-->
<h1 id="初衷---棘手的ts-808-tone部分">初衷 - 棘手的TS-808 Tone部分</h1>
<p>对于TS-808的原理，网上已有不少文章进行了讲解。然而，对于Tone部分（即Tone旋钮涉及的电路），我看到的一些资料都使用了比较简易的分析方法，即分析Tone旋钮为0以及Tone旋钮打满的两种情况。（以下图片摘自<a href="https://www.electrosmash.com/tube-screamer-analysis#tone-stage">electrosmash.com</a>）</p>
<figure>
<img src="../images/ac_analysis/tube-screamer-tone-volume.png" alt="TS-808 Tone Stage" />
<figcaption aria-hidden="true">TS-808 Tone Stage</figcaption>
</figure>
<figure>
<img src="../images/ac_analysis/ts808-tone-bass_side.png" alt="Tone为0时的等效电路" />
<figcaption aria-hidden="true">Tone为0时的等效电路</figcaption>
</figure>
<figure>
<img src="../images/ac_analysis/ts808-tone-treble_side.png" alt="Tone打满时的等效电路" />
<figcaption aria-hidden="true">Tone打满时的等效电路</figcaption>
</figure>
<p>那么，旋钮在0到10之间任何一个中间状态时应该如何分析？这时，我们可以基于理想运放的特性，去手算上述电路的transfer function。</p>
<p>可以肯定的是，这不会是一个轻松的过程。等待你的是无尽地等式书写和来回比较是否出现笔误。等到算出最终结果的时候，你很难说服自己中间有没有计算错误，因为结果看起来真的有点复杂。</p>
<p>如果你对该电路的transfer function感兴趣的话，Yeh博士在他的论文<a href="https://ccrma.stanford.edu/~dtyeh/papers/DavidYehThesisdoublesided.pdf">DIGITAL IMPLEMENTATION OF MUSICAL DISTORTION CIRCUITS BY ANALYSIS AND SIMULATION</a>中的2.4.3节给出了结果，下面的图片摘自这一部分。</p>
<figure>
<img src="../images/ac_analysis/yeh_808_tone.png" alt="Transfer Function of TS-808 Tone Stage" />
<figcaption aria-hidden="true">Transfer Function of TS-808 Tone Stage</figcaption>
</figure>
<p>那么，除了计算transfer function，有没有其他方法能够分析电路的频响特性呢？这个方法既不像手算transfer function如此考验耐心，此外也可作为一个验证手算的transfer function是否正确的工具。</p>
<p>答案是有的。这个方法就是SPICE中的AC Analysis。</p>
<h1 id="nodal-analysis和modified-nodal-analysis">Nodal Analysis和Modified Nodal Analysis</h1>
<p>介绍AC Analysis之前，我们需要了解一个名为Nodal Analysis的概念，这是一个用于求解电路上某个节点的电压的方法，它将其转化为方程组求解的问题。我们先来看以下场景：</p>
<figure>
<img src="../images/ac_analysis/cs_2res.png" style="width:60.0%" alt="电流源串联两个电阻" />
<figcaption aria-hidden="true">电流源串联两个电阻</figcaption>
</figure>
<p>为了求得节点1和节点2的电压，我们结合欧姆定律和基尔霍夫电流定律：</p>
<p><span class="math inline">\((V_1-V_2)/R_1 = I_s\)</span> （节点1）</p>
<p><span class="math inline">\((V_2-V_1)/R_1 + V_2/R_2 = 0\)</span> （节点2）</p>
<p>上述两个等式可看作是二元一次方程组，其中<span class="math inline">\(V_1\)</span>和<span class="math inline">\(V_2\)</span>为未知数。我们转换为矩阵形式。</p>
<p><span class="math inline">\(\begin{pmatrix}
1/R_1 &amp; -1/R_1 \\
-1/R_1 &amp; 1/R_1+1/R_2
\end{pmatrix}
\begin{pmatrix}
V_1 \\
V_2
\end{pmatrix} =
\begin{pmatrix}
I_s \\
0
\end{pmatrix}\)</span></p>
<p>总之，对于节点电压，基本的求解方法为：首先将电路中除了接地以外的所有节点根据欧姆定律和基尔霍夫电流定律得到等式，然后所有等式形成方程组，最后求解方程组。</p>
<p>这种分析和求解方法被称为Nodal Analysis。</p>
<p>下面我们再来看一个电压源的例子：</p>
<figure>
<img src="../images/ac_analysis/vs_3res.png" style="width:70.0%" alt="电压源串联三个电阻" />
<figcaption aria-hidden="true">电压源串联三个电阻</figcaption>
</figure>
<p>与电流源场景不同，这个场景中除了三个节点的电压为未知数以外，电压源的存在引入了新的未知数，即电压源本身的电流（下面标为<span class="math inline">\(I_s\)</span>）。不过，电压源本身也提供了<span class="math inline">\(V_1\)</span>和<span class="math inline">\(V_3\)</span>之间的电压差信息。于是我们可以得到一个四元一次方程组：</p>
<p><span class="math inline">\((V_1-V_2)/R_1 - I_s = 0\)</span> （节点1）</p>
<p><span class="math inline">\((V_2-V_1)/R_1 + V_2/R_2 = 0\)</span> （节点2）</p>
<p><span class="math inline">\(V_3/R_3 + I_s = 0\)</span> （节点3）</p>
<p><span class="math inline">\(V_1 - V_3 = V_s\)</span>（电压源信息）</p>
<p>其矩阵形式如下：</p>
<p><span class="math inline">\(\begin{pmatrix}
1/R_1 &amp; -1/R_1 &amp; 0 &amp; -1 \\
-1/R_1 &amp; 1/R_1+1/R_2 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1/R_3 &amp; 1 \\
1 &amp; 0 &amp; -1 &amp; 0 \\
\end{pmatrix}
\begin{pmatrix}
V_1 \\
V_2 \\
V_3 \\
I_s \\
\end{pmatrix} =
\begin{pmatrix}
0 \\
0 \\
0 \\
V_s
\end{pmatrix}\)</span></p>
<p>这个方法被称为Modified Nodal Analysis，是Nodal Analysis方法的延伸。后续我们主要基于该方法得到电路的频响信息。</p>
<h1 id="电路元件在modified-nodal-analysis中的表达">电路元件在Modified Nodal Analysis中的表达</h1>
<p>由上述Modified Nodal Analysis的例子可以看到，其核心在于根据各个节点连接的元件构造多元一次方程组并求解。这里，我们习惯将方程组写为矩阵形式：</p>
<div class="special-formula">
<span class="math inline">\(\mathbf{M}\mathbf{L}=\mathbf{R}\)</span>
</div>
<ul>
<li><span class="math inline">\(\mathbf{M}\)</span>为矩阵，包含各个元件的电导信息</li>
<li><span class="math inline">\(\mathbf{L}\)</span>为向量，包含待求解的节点电压和电压源的电流。</li>
<li><span class="math inline">\(\mathbf{R}\)</span>为向量，包含节点的电流信息和电压源的电压信息</li>
</ul>
<p>下面我们阐述各个元件如何应用到<span class="math inline">\(\mathbf{M}\)</span>、<span class="math inline">\(\mathbf{L}\)</span>以及<span class="math inline">\(\mathbf{R}\)</span>中。</p>
<h2 id="res_mna">电阻</h2>
<p>假设有下述场景，节点i和节点j之间有电阻R。</p>
<p><img src="../images/ac_analysis/res_mna.png" style="width:30.0%" /></p>
<p>根据前述的几个例子我们可知，电阻R对节点i和节点j有如下影响：</p>
<ul>
<li>对于节点i，电阻R使其流出<span class="math inline">\((V_i-V_j)/R\)</span>的电流，相当于对矩阵<span class="math inline">\(\mathbf{M}\)</span>有如下操作：
<ul>
<li><span class="math inline">\(\mathbf{M}_{ii}\)</span> += <span class="math inline">\(1/R\)</span></li>
<li><span class="math inline">\(\mathbf{M}_{ij}\)</span> += <span class="math inline">\(-1/R\)</span></li>
</ul></li>
<li>对于节点j，电阻R使其流出<span class="math inline">\((V_j-V_i)/R\)</span>的电流，相当于：
<ul>
<li><span class="math inline">\(\mathbf{M}_{jj}\)</span> += <span class="math inline">\(1/R\)</span></li>
<li><span class="math inline">\(\mathbf{M}_{ji}\)</span> += <span class="math inline">\(-1/R\)</span></li>
</ul></li>
</ul>
<p>总之，<span class="math inline">\(\mathbf{M}\)</span>、<span class="math inline">\(\mathbf{L}\)</span>、<span class="math inline">\(\mathbf{R}\)</span>有如下形式：</p>
<p><img src="../images/ac_analysis/res_mna-2.png" /></p>
<blockquote>
<p>在频域中，电容和电感可表示为阻抗形式，因此频域下这两者处理方式与电阻一致。</p>
</blockquote>
<h2 id="电压源">电压源</h2>
<p>由前述电压源的电路例子可知，电压源会引入了新的未知数，由此影响<span class="math inline">\(\mathbf{M}\)</span>、<span class="math inline">\(\mathbf{L}\)</span>、<span class="math inline">\(\mathbf{R}\)</span>三者的尺寸。另外，电压源又提供了两个节点的电压差信息。</p>
<p>我们观察以下电压源场景：</p>
<p><img src="../images/ac_analysis/vs_mna.png" style="width:30.0%" /></p>
<p>i到j的电流为新的未知数，我们标为<span class="math inline">\(I_s\)</span>。为了表达该信息，需要在向量<span class="math inline">\(\mathbf{L}\)</span>的末尾增加一行，我们假设在k位置。于是有：<span class="math inline">\(\mathbf{L}_k = I_s\)</span></p>
<p>下面我们分别对节点i和节点j进行分析：</p>
<ul>
<li>对于节点i，电压源使其<strong>流出</strong><span class="math inline">\(I_s\)</span>的电流，相当于<span class="math inline">\(\mathbf{M}_{ik} = 1\)</span></li>
<li>对于节点j，电压源使其<strong>流入</strong><span class="math inline">\(I_s\)</span>的电流，相当于<span class="math inline">\(\mathbf{M}_{jk} = -1\)</span></li>
</ul>
<p>另外，电压源提供了电压差信息：<span class="math inline">\(V_j - V_i = V_s\)</span>。同样，我们需要在向量<span class="math inline">\(\mathbf{R}\)</span>中添加一行来表示<span class="math inline">\(V_s\)</span>，其位置位于<span class="math inline">\(\mathbf{R}\)</span>的第k列，与<span class="math inline">\(I_s\)</span>在<span class="math inline">\(\mathbf{L}\)</span>中的一致。于是有：</p>
<ul>
<li><span class="math inline">\(\mathbf{M}_{kj} = 1\)</span></li>
<li><span class="math inline">\(\mathbf{M}_{ki} = -1\)</span></li>
<li><span class="math inline">\(\mathbf{R}_k = V_s\)</span></li>
</ul>
<p>总之，<span class="math inline">\(\mathbf{M}\)</span>、<span class="math inline">\(\mathbf{L}\)</span>、<span class="math inline">\(\mathbf{R}\)</span>有如下形式：</p>
<p><img src="../images/ac_analysis/vs_mna-2.png" /></p>
<h2 id="运放">运放</h2>
<p>这里我们考虑一个简易的运放模型。</p>
<p><img src="../images/ac_analysis/opamp_mna.png" style="width:30.0%" /></p>
<p>它有以下特性:</p>
<ul>
<li>不考虑供电电压</li>
<li><span class="math inline">\(V_k = Gain\times(V_j-V_i)\)</span>，其中<span class="math inline">\(Gain=1\times10^5\)</span></li>
</ul>
<blockquote>
<p><span class="math inline">\(Gain\)</span>越大，则运放的特性越理想。当<span class="math inline">\(Gain\)</span>无穷大时，有<span class="math inline">\(V_i = V_j\)</span>，即达到理想运放。</p>
</blockquote>
<p>下面，我们对运放的三个节点进行分析：</p>
<ul>
<li>对于节点i和j，其电流非常小，我们忽略，即不表示到Modified Nodal Analysis中</li>
<li>对于节点k，运放到节点k的电流未知，因此和电压源一样，需要引入一个新未知数<span class="math inline">\(I_{oa}\)</span>。然后在向量<span class="math inline">\(\mathbf{L}\)</span>的末尾添加一行存放该信息，我们假设其位置为l。于是有：<span class="math inline">\(\mathbf{L}_l = I_{oa}\)</span></li>
</ul>
<p>此外，我们需要将<span class="math inline">\(V_k = Gain\times(V_j-V_i)\)</span>表示到Modified Nodal Analysis中。于是有：</p>
<ul>
<li><span class="math inline">\(\mathbf{M}_{li} = Gain\)</span></li>
<li><span class="math inline">\(\mathbf{M}_{lj} = -Gain\)</span></li>
<li><span class="math inline">\(\mathbf{M}_{lk} = 1\)</span></li>
</ul>
<p>可以看到，等式<span class="math inline">\(V_k = Gain\times(V_j-V_i)\)</span>已在矩阵<span class="math inline">\(\mathbf{M}\)</span>中表达完毕，所以向量<span class="math inline">\(\mathbf{R}\)</span>中添加一行值为0的元素即可，即<span class="math inline">\(\mathbf{R}_l = 0\)</span>。</p>
<p>总之，<span class="math inline">\(\mathbf{M}\)</span>、<span class="math inline">\(\mathbf{L}\)</span>、<span class="math inline">\(\mathbf{R}\)</span>有如下形式：</p>
<p><img src="../images/ac_analysis/opamp_mna-2.png" /></p>
<h1 id="ac-analysis的实现">AC Analysis的实现</h1>
<p>上面我们介绍了几种电路元件在Modified Nodal Analysis中的表达。基于上述原理，我们可以求解某个电路的各个节点的电压了。下面我们更细节地描述整个流程，并尝试实现代码。</p>
<p>整个流程大致分为：</p>
<ul>
<li>矩阵<span class="math inline">\(\mathbf{M}\)</span>和向量<span class="math inline">\(\mathbf{R}\)</span>的初始化</li>
<li>电路表达至矩阵<span class="math inline">\(\mathbf{M}\)</span>和向量<span class="math inline">\(\mathbf{R}\)</span>中</li>
<li>frequency sweep与频响的计算</li>
</ul>
<h2 id="矩阵m和向量r的初始化">矩阵M和向量R的初始化</h2>
<p>首先，我们需要确定矩阵<span class="math inline">\(\mathbf{M}\)</span>和向量<span class="math inline">\(\mathbf{R}\)</span>的尺寸。</p>
<p>由前述可知，其受两个因素影响：</p>
<ul>
<li>电路中的节点数（不需要包括接地）</li>
<li>电路中有电压源性质的元件数（包括电压源、运放等）</li>
</ul>
<p>我们以同相放大电路为例：</p>
<p><img src="../images/ac_analysis/non-invert-amp.png" style="width:50.0%" /></p>
<p>电路中包含4个节点以及2个电压源元件（信号源Vin以及一个运放），可得尺寸为：<span class="math inline">\(4+2=6\)</span>。即矩阵<span class="math inline">\(\mathbf{M}\)</span>的尺寸为(6, 6)，向量<span class="math inline">\(\mathbf{R}\)</span>的尺寸为6。</p>
<h3 id="相关代码">相关代码</h3>
<p>首先，我们对元件类进行定义，如下：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> List</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Component():</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, nodes: List[<span class="bu">int</span>]):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes <span class="op">=</span> nodes</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span></code></pre></div>
<p>其中，nodes成员为列表类型，存放与元件关联的节点。如上述同相放大电路中的R1，其nodes成员为[1, 4]。</p>
<p>基于Component类，我们可以定义例如电阻和电压源：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Resistor(Component):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, R: <span class="bu">float</span>, nodes: List[<span class="bu">int</span>]):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(nodes)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.R <span class="op">=</span> R <span class="co"># 阻值</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VoltageSource(Component):</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, V: <span class="bu">float</span>, nodes: List[<span class="bu">int</span>]):</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(nodes)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.vsn <span class="op">=</span> <span class="va">None</span> <span class="co"># 电压源会引入新未知数，vsn用于标记该未知数所在向量中的相对于其他电压源未知数的位置</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.V <span class="op">=</span> V <span class="co"># 电压源的电压大小</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> set_vs_num(<span class="va">self</span>, vsn: <span class="bu">int</span>):</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.vsn <span class="op">=</span> vsn</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_vs_num(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.vsn</span></code></pre></div>
<p>然后，我们定义电路类，其存放完整的元件连接逻辑以及ac analysis的实现。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Circuit():</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, components: List[Component], output_node: <span class="bu">int</span>):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.components <span class="op">=</span> components <span class="co"># 电路中所有的元件</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output_node <span class="op">=</span> output_node <span class="co"># 表示ac analysis输出哪个节点的频响结果</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ckt_matrix <span class="op">=</span> <span class="va">None</span> <span class="co"># Modified Nodal Analysis中的矩阵M</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ckt_rhs <span class="op">=</span> <span class="va">None</span> <span class="co"># Modified Nodal Analysis中的向量R</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        node_count <span class="op">=</span> <span class="dv">0</span> <span class="co"># 电路中的节点数</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        vs_count <span class="op">=</span> <span class="dv">0</span> <span class="co"># 电路中的电压源个数</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> comp <span class="kw">in</span> <span class="va">self</span>.components:</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            node_count <span class="op">=</span> <span class="bu">max</span>(node_count, <span class="bu">max</span>(comp.nodes))</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">isinstance</span>(comp, VoltageSource):</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>                comp.set_vs_num(vs_count)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>                vs_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        matrix_size <span class="op">=</span> node_count <span class="op">+</span> vs_count <span class="co"># 两者相加为方程组的尺寸</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ckt_matrix <span class="op">=</span> np.zeros((matrix_size, matrix_size), dtype<span class="op">=</span><span class="bu">complex</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ckt_rhs <span class="op">=</span> np.zeros(matrix_size, dtype<span class="op">=</span><span class="bu">complex</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.node_count <span class="op">=</span> node_count <span class="co"># 后续定位电压源相关变量的位置会用到</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> ac_analysis(<span class="va">self</span>):</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 我们稍后实现</span></span></code></pre></div>
<h2 id="电路表达至mr中">电路表达至M、R中</h2>
<p>在对矩阵<span class="math inline">\(\mathbf{M}\)</span>和向量<span class="math inline">\(\mathbf{R}\)</span>进行初始化后，我们需要将元件表达到其中。这里，我们需要所有电路元件实现stamp()函数来完成该任务。依旧以电阻和电压源为例。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Resistor(Component):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> stamp(<span class="va">self</span>, circuit):</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="va">self</span>.R</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        circuit.stamp_conductance(<span class="va">self</span>.nodes[<span class="dv">0</span>], <span class="va">self</span>.nodes[<span class="dv">1</span>], G)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VoltageSource(Component):</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> stamp(<span class="va">self</span>, circuit):</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        circuit.stamp_voltage_source(<span class="va">self</span>.nodes[<span class="dv">0</span>], <span class="va">self</span>.nodes[<span class="dv">1</span>], <span class="va">self</span>.vsn, <span class="va">self</span>.V)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Circuit():</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> stamp_matrix(<span class="va">self</span>, n1, n2, val):</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n1 <span class="op">&lt;=</span> <span class="dv">0</span> <span class="kw">or</span> n2 <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        n1 <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        n2 <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ckt_matrix[n1][n2] <span class="op">+=</span> val</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> stamp_rhs(<span class="va">self</span>, n, val):</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        n <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ckt_rhs[n] <span class="op">+=</span> val</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> stamp_conductance(<span class="va">self</span>, n1, n2, G):</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stamp_matrix(n1, n1, G)</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stamp_matrix(n2, n2, G)</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stamp_matrix(n1, n2, <span class="op">-</span>G)</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stamp_matrix(n2, n1, <span class="op">-</span>G)</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> stamp_voltage_source(<span class="va">self</span>, n1, n2, vsn, voltage):</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>        vn <span class="op">=</span> <span class="va">self</span>.node_count <span class="op">+</span> vsn <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stamp_matrix(n1, vn, <span class="dv">1</span>)</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stamp_matrix(n2, vn, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stamp_matrix(vn, n1, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stamp_matrix(vn, n2, <span class="dv">1</span>)</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stamp_rhs(vn, voltage)</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span></code></pre></div>
<p>可以看到，上述代码运用之前介绍的将元件表达到Modified Nodal Analysis的原理。比如，电阻类的stamp(…)函数中主要调用了Circuit.stamp_conductance(…)，其流程与前述的“电阻”部分<a href="#res_mna">^</a>一致。</p>
<h3 id="电容如何表达">电容如何表达？</h3>
<p>我们知道，频域下电容有容抗公式 <span class="math inline">\(X = \frac{1}{j2{\pi}fC}\)</span>。因此，其依旧遵循电阻的处理逻辑，只不过需要扩展Modified Nodal Analysis到复数域，并且其阻抗和频率相关。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Capacitor(Component):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, C, nodes):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(nodes)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.C <span class="op">=</span> C <span class="co"># 电容值</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> stamp(<span class="va">self</span>, circuit):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        cur_freq <span class="op">=</span> circuit.get_current_freq() <span class="co"># 获取当前频率</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> <span class="bu">complex</span>(<span class="dv">0</span>, <span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>cur_freq<span class="op">*</span><span class="va">self</span>.C) <span class="co"># 计算电导，容抗公式的倒数</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        circuit.stamp_conductance(<span class="va">self</span>.nodes[<span class="dv">0</span>], <span class="va">self</span>.nodes[<span class="dv">1</span>], G)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Circuit():</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, components: List[Component]):</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ..</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cur_freq <span class="op">=</span> <span class="dv">440</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_current_freq(<span class="va">self</span>):</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.cur_freq</span></code></pre></div>
<h2 id="frequency-sweep与频响的计算">frequency sweep与频响的计算</h2>
<p>上面我们得到了电阻和电容的代码表达，下面我们以一个一阶RC电路为例介绍如何计算其频响。</p>
<p><img src="../images/ac_analysis/rc_ckt.png" style="width:50.0%" /></p>
<p>首先，我们通过代码表示上述电路，如下：</p>
<pre><code>rc_ckt = Circuit(components = [
                  VoltageSource(V = 1, nodes = [0, 1]),
                  Resistor(R = 500e3, nodes = [1, 2]),
                  Capacitor(C = 1e-9, nodes = [2, 0])
                ],
                output_node = 2)</code></pre>
<p>其中，VoltageSource对应Vin，分析频响一般会以幅值为1的正弦波作为输入，因此V=1。我们关注节点2的频响，因此output_node为2。</p>
<h3 id="如何计算某个频率下的频响">如何计算某个频率下的频响？</h3>
<p>在完成了上述构造后，为了得到某个频率下的响应，我们需要做的无非就是这几个步骤：</p>
<ul>
<li>将元件分别stamp到矩阵<span class="math inline">\(\mathbf{M}\)</span>和向量<span class="math inline">\(\mathbf{R}\)</span>中</li>
<li>求解矩阵<span class="math inline">\(\mathbf{M}\)</span>和向量<span class="math inline">\(\mathbf{R}\)</span>组成的方程组</li>
</ul>
<p>我们在下述的ac_analysis()成员函数中实现之：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Circuit():</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> ac_analysis(<span class="va">self</span>):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 初始化矩阵M和向量R</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ckt_matrix[:][:] <span class="op">=</span> <span class="bu">complex</span>(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ckt_rhs[:] <span class="op">=</span> <span class="bu">complex</span>(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 所有元件进行stamp，表示到矩阵M和向量R中</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> comp <span class="kw">in</span> <span class="va">self</span>.components:</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            comp.stamp(<span class="va">self</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 矩阵求解</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        solution <span class="op">=</span> np.linalg.solve(<span class="va">self</span>.ckt_matrix, <span class="va">self</span>.ckt_rhs)</span></code></pre></div>
<h3 id="ac-analysis指令拆解">ac analysis指令拆解</h3>
<p>在SPICE电路仿真中，如果想要分析电路中一个节点在10到10k之间的频响，可以执行以下指令：</p>
<pre><code>.ac dec 100 1 10k</code></pre>
<p>上面指令中：</p>
<ul>
<li>.ac: 代表做ac analysis，即频响分析</li>
<li>1: 代表频率起点，即1Hz</li>
<li>10k: 代表频率终点，即10kHz</li>
<li>dec: 代表将频率起点到终点以对数等分分为多个”区域”。于是，该指令会分为如下区域：
<ul>
<li>1 ~ 10Hz</li>
<li>10 ~ 100Hz</li>
<li>100 ~ 1000Hz</li>
<li>1000 ~ 10kHz</li>
</ul></li>
<li>100: 代表每个”区域”生成100个点。在dec下，这100个点也遵循对数等分的规则，即某点与其前一点的频率相除为<span class="math inline">\(\sqrt[100]{10}\)</span></li>
</ul>
<p>可以看到，ac analysis就是将一个频率范围转化为离散的频率点，然后依次计算每个频率点的频响。这也被称为扫频（frequency sweep）。</p>
<h3 id="frequency-sweep实现">frequency sweep实现</h3>
<p>由于我们前面已经对单个频率点的响应求解进行了实现，frequency sweep的实现就是将其嵌入到循环中即可。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Circuit():</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, components: List[Component], output_node: <span class="bu">int</span>):</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># .ac dec 100 1 10K</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.start_freq <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.end_freq <span class="op">=</span> <span class="fl">1e4</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.mulStep <span class="op">=</span> np.power(<span class="dv">10</span>, <span class="fl">0.01</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> ac_analysis(<span class="va">self</span>):</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        freq_arr <span class="op">=</span> [] <span class="co"># 所有的频率点</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        response_arr <span class="op">=</span> [] <span class="co"># 所有频率点对应的响应</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cur_freq <span class="op">=</span> <span class="va">self</span>.start_freq <span class="co"># 从频率起点开始</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">self</span>.cur_freq <span class="op">&lt;</span> <span class="va">self</span>.end_freq:</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 求单个频率点下的响应，同上</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.ckt_matrix[:][:] <span class="op">=</span> <span class="bu">complex</span>(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.ckt_rhs[:] <span class="op">=</span> <span class="bu">complex</span>(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> comp <span class="kw">in</span> <span class="va">self</span>.components:</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>                comp.stamp(<span class="va">self</span>)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            solution <span class="op">=</span> np.linalg.solve(<span class="va">self</span>.ckt_matrix, <span class="va">self</span>.ckt_rhs)</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>            freq_arr.append(<span class="va">self</span>.cur_freq) <span class="co"># 当前频率点入list</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>            response_arr.append(solution[<span class="va">self</span>.output_node <span class="op">-</span> <span class="dv">1</span>]) <span class="co"># 指定节点响应入list。注意，方程组表达从节点1开始，所以节点在solution的位置为self.output_node - 1。</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.cur_freq <span class="op">*=</span> <span class="va">self</span>.mulStep <span class="co"># 获取下一个频率点</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> freq_arr, response_arr</span></code></pre></div>
<p>通过ac_analysis()的返回，我们以频率点作为横坐标，将响应转换为幅值和相位作为纵坐标，从而画出频响曲线：</p>
<p><img src="../images/ac_analysis/rc_ckt-freq_resp.png" /></p>
<p>如果想了解其他元件，比如电感、电位器的实现，可以参考这个项目<a href="https://github.com/Arthritiz/little_ac_analysis">little_ac_analysis</a></p>
<h1 id="ts-808-tone-stage频响分析">TS-808 Tone Stage频响分析</h1>
<p>最后，我们回到文章开头提及的TS-808 Tone Stage电路，尝试获取其在不同Tone值下的频响曲线，并观察Tone值对频响的影响。</p>
<p>首先，我们在工具里构造该电路:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>ts808_tone_stage <span class="op">=</span> Circuit(</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                        components <span class="op">=</span> [</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                            VoltageSource(V<span class="op">=</span><span class="dv">1</span>, nodes<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>]),</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                            OpAmp(nodes<span class="op">=</span>[<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]),</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>                            Resistor(R<span class="op">=</span><span class="fl">1e3</span>, nodes<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">3</span>]),</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>                            Resistor(R<span class="op">=</span><span class="fl">1e3</span>, nodes<span class="op">=</span>[<span class="dv">2</span>, <span class="dv">4</span>]),</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>                            Capacitor(C<span class="op">=</span><span class="fl">220e-9</span>, nodes<span class="op">=</span>[<span class="dv">6</span>, <span class="dv">5</span>]),</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                            Resistor(R<span class="op">=</span><span class="dv">220</span>, nodes<span class="op">=</span>[<span class="dv">5</span>, <span class="dv">0</span>]),</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>                            Potentiometer(R<span class="op">=</span><span class="fl">20e3</span>, nodes<span class="op">=</span>[<span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">3</span>], label<span class="op">=</span><span class="st">'Tone Knob'</span>),</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>                            Resistor(R<span class="op">=</span><span class="fl">10e3</span>, nodes<span class="op">=</span>[<span class="dv">3</span>, <span class="dv">0</span>]),</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>                            Capacitor(C<span class="op">=</span><span class="fl">220e-9</span>, nodes<span class="op">=</span>[<span class="dv">3</span>, <span class="dv">0</span>])</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>                        ],</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>                        output_node <span class="op">=</span> <span class="dv">4</span>,</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>                        name <span class="op">=</span> <span class="st">&quot;TS-808 Tone Stage&quot;</span>)</span></code></pre></div>
<p>components中的Potentiometer为电位器，与TS-808 Tone Stage中的Tone旋钮对应。</p>
<p>我们通过调节Potentiometer的设置依次得到Tone旋钮从0到10的频响，得到以下plot结果，我们可以调整滑块来观察不同Tone值的频响变化。</p>
<iframe src="../embeds/ts-808-tone-freq_resp.html">
</iframe>
<p>可以看到，Tone钮在0到1之间，频响变化主要集中在1k~5kHz这个区域。</p>
<p>而Tone钮在2到6之间，曲线呈现类似低通的特性。</p>
<p>Tone钮在7到10之间，中频部分逐渐鼓起。并且9到10之间虽然只是较小的调整，但9和10强调的中频区域有明显区别。</p>
<h1 id="更多的探索">更多的探索</h1>
<p>本文我们实现了一个AC Analysis工具，用于生成各种电路的频响曲线。我们可以在得到频响数据的基础上进行各种自定义的绘制以便观察电路特性。之后的文章我们将用该工具探索更多电路。</p>
    </div>
</div>
        </div>

        <hr>
        <div class="footer">
            <p>Powered by <a href="http://jaspervdj.be/hakyll">Hakyll</a>. Style from <a href="https://github.com/travisbrown/metaplasm">metaplasm</a> & <a href="https://github.com/zhe/hugo-theme-slim">slim</a>.</p>
        </div>

    
    </div>
    
    <script src="../js/slim.js"></script>

    </body>

</html>